<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Remembuddy</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; font-family: system-ui, sans-serif; background-color: #1e1e1e; color: #eee; }
    header { background-color: #111; padding: 1rem; text-align: center; font-size: 1.5rem; font-weight: bold; color: #00ffcc; }
    main { display: flex; flex-direction: column; height: calc(100% - 64px); }
    .chat-area { flex: 1; overflow-y: auto; padding: 1rem; }
    .input-wrapper { border-top: 1px solid #333; background-color: #111; padding: 1rem; display: flex; gap: 0.5rem; align-items: center; }
    select, textarea, button { font-size: 1rem; }
    select { padding: 0.75rem; border-radius: 5px; border: 1px solid #333; background-color: #2b2b2b; color: #99cc99; }
    textarea { flex: 1; padding: 0.75rem; border-radius: 5px; border: 1px solid #333; background-color: #2b2b2b; color: #99cc99; resize: vertical; min-height: 80px; }
    button { padding: 0.75rem 1.5rem; border-radius: 5px; border: none; background-color: #006633; color: #e6e6e6; cursor: pointer; }
    button:hover { background-color: #008844; }
    .message { margin-bottom: 1rem; padding: 0.75rem 1rem; border-radius: 12px; max-width: 90%; clear: both; }
    .user-message { background-color: #2c2c2e; color: #fff; align-self: flex-end; float: right; }
    .ai-message { background-color: #3a3a3c; color: #fff; align-self: flex-start; float: left; }
    .system-message { background: none; color: #888; text-align: center; margin: 1rem 0; }
    .error { color: #cc5555; text-align: center; margin-top: 0.5rem; }
  </style>
</head>
<body>
  <header>Remembuddy</header>
  <main>
    <div id="chatBox" class="chat-area"></div>
    <div class="input-wrapper">
      <select id="modelSelect"></select>
      <textarea id="userInput" placeholder="Type your message..."></textarea>
      <button id="sendButton">Send</button>
    </div>
  </main>

  <script>
  document.addEventListener('DOMContentLoaded', async () => {
    const chatBox = document.getElementById('chatBox');
    const sendBtn = document.getElementById('sendButton');
    const modelSelect = document.getElementById('modelSelect');
    const inputArea = document.getElementById('userInput');
    let chatHistory = [];
      let memory = [];
    let memory = [];

    function appendMessage(role, content) {
      const wrapper = document.createElement('div');
      const cls = role === 'You' ? 'user-message' : role === 'AI' ? 'ai-message' : 'system-message';
      wrapper.className = 'message ' + cls;
      if (role === 'You' || role === 'AI') {
        const sender = document.createElement('div'); sender.className = 'sender'; sender.textContent = role;
        wrapper.appendChild(sender);
      }
      wrapper.appendChild(document.createTextNode(content));
      chatBox.appendChild(wrapper);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    async function loadModels() {
      modelSelect.disabled = true;
      modelSelect.innerHTML = '<option>Loading models...</option>';
      if (window.location.protocol === 'file:') {
        modelSelect.innerHTML = '<option>llama3:8b</option>';
        appendMessage('System', '⚠️ Serve over HTTP(S) to load models dynamically.');
        modelSelect.disabled = false;
        return;
      }
      try {
        const res = await fetch('/api/models');
        const data = await res.json();
        let modelsArr = [];
        if (Array.isArray(data)) modelsArr = data;
        else if (Array.isArray(data.models)) modelsArr = data.models;
        modelSelect.innerHTML = '';
        modelsArr.forEach(m => {
          const name = typeof m === 'string' ? m : (m.name || m.id || JSON.stringify(m));
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name;
          modelSelect.appendChild(opt);
        });
        if (modelSelect.options.length === 0) {
          modelSelect.innerHTML = '<option value="llama3:8b">llama3:8b</option>';
        }
        const defaultOpt = modelSelect.querySelector('option[value="llama3:8b"]');
        if (defaultOpt) modelSelect.value = 'llama3:8b';
      } catch (e) {
        console.error('Model load error', e);
        modelSelect.innerHTML = '<option value="llama3:8b">llama3:8b</option>';
      } finally {
        modelSelect.disabled = false;
      }
    }

    async function loadMemory() {
        try {
          const res = await fetch('/api/memory');
          if (!res.ok) throw new Error(`Memory load failed: ${res.status}`);
          memory = await res.json();
          appendMessage('System', `Memory loaded: ${memory.length}`);
        } catch (e) {
          console.error('Memory load error', e);
          appendMessage('System', 'Error loading memory.');
        }
      }
      try {
        const res = await fetch(brainUrl);
        if (res.status === 404) {
          const apiRes = await fetch('/api/memory');
          if (apiRes.ok) {
            const apiData = await apiRes.json();
            if (Array.isArray(apiData)) {
              memory = apiData;
              appendMessage('System', `Memory loaded from API: ${memory.length}`);
              return;
            }
          }
          await fetch(brainUrl, { method: 'POST', headers: {'Content-Type':'application/json'}, body: '[]' });
          memory = [];
          appendMessage('System', 'Created new brain.json.');
          return;
        }
        if (!res.ok) throw new Error(res.statusText);
        memory = await res.json();
        appendMessage('System', `Memory loaded: ${memory.length}`);
      } catch (e) {
        console.error('Memory load error', e);
        appendMessage('System', 'Error loading memory.');
      }
    }

    async function sendMessage() {
      const text = inputArea.value.trim(); if (!text) return;
      appendMessage('You', text);
      chatHistory.push({ role: 'user', content: text });
      inputArea.value = '';

      const msgs = [...memory.map(m => ({ role: 'system', content: `${m.timestamp}: ${m.summary}` })), ...chatHistory];
      const payload = { messages: msgs, model: modelSelect.value };
      try {
        const res = await fetch('/api/chat', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload) });
        if (!res.ok) { const errText = await res.text(); appendMessage('System', `Chat error ${res.status}: ${errText}`); return; }
        let data;
        try { data = await res.json(); } catch (jsErr) { const txt = await res.text(); appendMessage('System', `Invalid JSON: ${jsErr.message}: ${txt}`); return; }
        const aiMsg = data.message?.content || JSON.stringify(data);
        appendMessage('AI', aiMsg);
        chatHistory.push({ role: 'assistant', content: aiMsg });

        // Summarize silently
        let summary = '';
        try {
          const sumRes = await fetch('/api/summarize', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ user: text, ai: aiMsg }) });
          if (sumRes.ok) {
            const json = await sumRes.json();
            summary = json.summary || '';
          }
        } catch (e) {
          console.error('Summarization error', e);
        }

        const timestamp = new Date().toISOString();
        memory.push({ timestamp, summary });

                // Persist memory by appending the latest entry
        try {
          await fetch('/api/memory', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ timestamp, summary })
          });
        } catch (e) {
          console.error('Memory save error', e);
          appendMessage('System', 'Error saving memory.');
        }
      });
        if (saveRes.status === 404) {
          for (const entry of memory) {
            await fetch('/api/memory', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(entry) });
          }
        }
      } catch (e) {
        console.error('Send error', e);
        appendMessage('System', 'Network or server error.');
      }
    }

    sendBtn.addEventListener('click', sendMessage);
    inputArea.addEventListener('keydown', e => { if (e.key === 'Enter' && e.shiftKey) { e.preventDefault(); sendMessage(); } });

    await loadModels();
    await loadMemory();
  });
  </script>
</body>
</html>
